
from collections import namedtuple
import pprint
import math
from datetime import datetime

BERLIN_INTERVAL = 120000000

pp = pprint.PrettyPrinter(indent=2)

class DeviceScanner:
    """Device scanner object."""


    #def scan_devices(self) -> List[str]:
    def scan_devices(self):
        """Scan for devices."""
        raise NotImplementedError()

    #def get_device_name(self, device: str) -> str:
    def get_device_name(self, device: str):
        """Get the name of a device."""
        raise NotImplementedError()

    #def get_extra_attributes(self, device: str) -> dict:
    def get_extra_attributes(self, device: str):
        """Get the extra attributes of a device."""
        raise NotImplementedError()


#    Station MAC, First time seen, Last time seen, Power, # packets, BSSID, Probed ESSIDs
#    XX:XX:XX:XX:XX:XX, 2019-11-01 17:44:47, 2019-11-01 17:47:16,  -1,      183, XX:XX:XX:XX:XX:XX,

# -berlin (if the last packet seen is higher than 2 minutes, the AP isn't shown anymore)

Device = namedtuple("Device", [ "mac", "name", "ssid", "channel", "power", "distance", "last_seen" ])

#XX:XX:XX:XX:XX:XX, 2019-11-05 14:36:35, 2019-11-05 15:58:59,  8, 195, WPA2, CCMP, PSK, -27,    23702,    57447,   0.  0.  0.  0,   6, TestNET,
AccessPoints = namedtuple("AccessPoints", ["bssid","channel", "ssid"])

class AirodumpDeviceScanner(DeviceScanner):
    """This class scans for devices from airodump output csv file."""

    exclude = []

    def __init__(self):
        """Initialize the scanner."""
        #self.access_points_found = []
        self.devices_found = []


    def _update_info(self):
        """Scan the output csv file generated by airodump-ng for devices.

        Returns boolean if scanning successful.
        """
        devices_found = []
        access_points_found = []

        try:
            with open('/tmp/airodump-01.csv') as f:
                lineList = [line.rstrip() for line in f]

                #now = dt_util.now() same??
                now = datetime.now()

                for line in lineList:
                    cols = line.split(",")
                    mac_groups = cols[0].strip().split(":")

                    if len( mac_groups ) == 6: #check bssid & mac is valid
                        if len(cols) >= 14:
                            #accesspoint entry in the file
                            bssid = cols[0].strip().upper()
                            channel = cols[3].strip()
                            ssid = cols[13].strip()
                            access_points_found.append( AccessPoints(bssid, channel, ssid) )


                        elif len(cols) >= 7:
                            #device entry in the file
                            mac = cols[0].strip().upper()
                            bssid = cols[5].strip().upper()
                            power = cols[3].strip()
                            lastseen_str = cols[2].strip()

                            try:
                                lastseen = datetime.strptime(lastseen_str, '%Y-%m-%d %H:%M:%S')
                            except ValueError:
                                #em..probably the Last seen time string or invalid..just ignore
                                continue

                            lastseen_seconds = (now - lastseen).total_seconds()

                            #Seams the -a(filter associated devices) and --berlin filters work only for the scren output, NOT for the file, so we need to filter them here
                            #1. check if associated to our access points
                            #  plus we need the channel to get better distance estimations
                            #2. return only devices that have last seen datetime less then a value
                            filtered_accespoint = [ accespoint for accespoint in access_points_found if accespoint.bssid == bssid ]
                            if filtered_accespoint and lastseen_seconds > 0 and lastseen_seconds < BERLIN_INTERVAL:
                                #Associated, take needed info also from accesspoints and save them as a Device object
                                channel = filtered_accespoint[0].channel
                                ssid = filtered_accespoint[0].ssid
                                name = 'dev_' + mac_groups[0] + "_" + mac_groups[1]
                                channel = filtered_accespoint[0].channel
                                try:
                                    distance = convert_power_to_distance( int(power) , int(channel) )
                                except ValueError:
                                    continue

                                #dt_now = dt_util.now();
                                devices_found.append( Device(mac, name, ssid, channel, power, distance, lastseen) )


                f.close()

        except OSError as e:
            print(e.strerror)

        self.devices_found = devices_found

        print("access_points_found: ")
        pp.pprint(access_points_found)
        print("devices_found: ")
        pp.pprint(devices_found)


        return True

    def scan_devices(self):
        """Scan for new devices and return a list with found device IDs."""
        self._update_info()
        #print("scan_devices")

        #devices = ['A','B','C']

        #_LOGGER.debug("Airodump last results %s", self.last_results)

        #return [device.mac for device in self.last_results]
        #print(self.last_results)
        return [device.mac for device in self.devices_found]

    def get_device_name(self, device):
        """Return the extra attributes(for ex distance(m)) of the given device."""
        return None

    def get_extra_attributes(self, device):
        """Return the distance(m) of the given device."""
        filter_device = next(
            (result for result in self.devices_found if result.mac == device), None
        )
        return {"ssid": filter_device.ssid, "channel": filter_device.channel, "power": filter_device.power, "distance": filter_device.distance, "last_seen": filter_device.last_seen}

def getDelta( datetimestr ):
    #2019-11-01 17:33:15
    try:
        datetime_object = datetime.strptime(datetimestr, '%Y-%m-%d %H:%M:%S')
    except ValueError:
        print("Invalid datetime")
        return
    now = datetime.now()
    pp.pprint(datetime_object)
    pp.pprint(now)
    delta = now - datetime_object
    if delta.total_seconds()  > 120:
        print("expired time")
    pp.pprint(delta.total_seconds())


def convert_power_to_distance(power_dBm, wifi_channel):
    #rx power measured 1m from the transmitter clear line of sight
    P0 = -40 #calculate it based on txpower also
    alpha = 4
    if wifi_channel > 14: #5G channel
        alpha = 4
        P0 = -55
    distance = math.ceil ( math.pow(10, -((power_dBm - P0)/(10*alpha))) )
    return distance

#getDelta('2019-11-06 12:07:00')
#getDelta('Last time seen')

#print( convert_power_to_distance(-52, 8) )
#print( convert_power_to_distance(-75, 8) )
#print( convert_power_to_distance(-52, 36) )
#print( convert_power_to_distance(-75, 36) )
#print( convert_power_to_distance(-67, 36) )
#print( convert_power_to_distance(-88, 36) )

#d = convert_power_to_distance(-75, 8)
#print("d= ",d, " m")

airo = AirodumpDeviceScanner()
airo.scan_devices()
pp.pprint( airo.get_extra_attributes('XX:XX:XX:XX:XX:XX'))
